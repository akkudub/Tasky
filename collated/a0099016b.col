//@author: a0099016b



	/**
	 * origin: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\FileProcessing.cpp
	 */

#include "FileProcessing.h"


int FileProcessing::load(vector<string>& data){
	try{
		ifstream input(_LOGNAME);
		if(!input.is_open()) 
			return STATUS_CODE_SET_ERROR::ERROR_LOAD_OPENFILE;
		if (!input.good()){
			LogLibrary::Log::writeLog(LogLibrary::STATUS_CODE_SET_LOG::LOG_ERROR, "Error in opening file","FileProcessingLog");
			return STATUS_CODE_SET_ERROR::ERROR_LOAD_OPENFILE;
		}
		if (emptyFile()){
			input.close();
			LogLibrary::Log::writeLog(LogLibrary::STATUS_CODE_SET_LOG::LOG_WARNING,"Empty file","FileProcessingLog");
			return STATUS_CODE_SET_WARNING::WARNING_LOAD_EMPTY_FILE;	
		}
		readLines(input,data);
		input.close();
		if (data.size() % TASKLINES != 0) {
			LogLibrary::Log::writeLog(LogLibrary::STATUS_CODE_SET_LOG::LOG_ERROR, "Corrupted data while loading file","FileProcessingLog");
			return STATUS_CODE_SET_ERROR::ERROR_LOAD_CORRUPTED_DATA;
		}
		return STATUS_CODE_SET_SUCCESS::SUCCESS_LOAD;
	}catch(exception e) {
		LogLibrary::Log::writeLog(LogLibrary::STATUS_CODE_SET_LOG::LOG_ERROR,"Error in opening file","FileProcessingLog");
		return STATUS_CODE_SET_ERROR::ERROR_LOAD_OPENFILE;
	}
}

void FileProcessing::readLines(ifstream& input, vector<string>& data){
	data.clear();
	while(input) {
		string line;
		getline(input, line);
		if (line != "\n" && line != ""){
			data.push_back(line);
		}
	}
}


int FileProcessing::save(vector<string>& data){
	try{
		ofstream output(_LOGNAME);
		if (!output.is_open()) {
			output.clear();
			output.open(_LOGNAME, ofstream::out|ofstream::trunc);
		}
		if (!output.good()){
			output.close();
			LogLibrary::Log::writeLog(LogLibrary::STATUS_CODE_SET_LOG::LOG_ERROR,"Error in saving file","FileProcessingLog");
			return STATUS_CODE_SET_ERROR::ERROR_SAVE_SAVEFILE;
		}
		writeLines(output,data);

		output.close();
		return STATUS_CODE_SET_SUCCESS::SUCCESS_SAVE;
	}catch(exception e){
		LogLibrary::Log::writeLog(LogLibrary::STATUS_CODE_SET_LOG::LOG_ERROR,"Error in saving file","FileProcessingLog");
		return STATUS_CODE_SET_ERROR::ERROR_SAVE_SAVEFILE;
	}
}

void FileProcessing::writeLines(ofstream& output, vector<string>& data){
	int countLine = 0;
	for(string s:data) {
		output << s << endl;
		countLine++;
		if (countLine >= TASKLINES){
			output << endl;
			countLine = 0;
		}
	}
}


bool FileProcessing::emptyFile() {
	bool isEmpty = false;
	ifstream inf;
	inf.open(_LOGNAME);
	if(inf.peek() == ifstream::traits_type::eof())
		isEmpty = true;
	inf.close();
	return isEmpty;
}

	// End of segment: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\FileProcessing.cpp





	/**
	 * origin: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\FileProcessing.h
	 */


#include <fstream>
#include "Essential.h"
#include "LogLibrary/Log.h"

static const string _LOGNAME = "Tasky.txt";
static const int TASKLINES = 6;

class FileProcessing{
private:
	/**
	* Purpose:
	* Checks if the file Log is empty
	*@return True - File Log is empty, False - File Log not empty
	*/
	bool emptyFile();
	void readLines(ifstream& input, vector<string>& data);
	void writeLines(ofstream& output, vector<string>& data);
public:
	/**
	* Purpose:
	* Checks if file Log exists
	* If it exists, reads and load the tasks from file Log into vector<string> data
	* @param data - vector to be loaded with tasks from Log
	*@return Success in loading file; File Log does not exist; File Log is empty
	*/
	int load(vector<string>& data); 
	/**
	* Purpose:
	* Checks if file Log exist
	* If it exists, writes the task from vector<string> data into file Log
	* If it does not exist, create a file Log
	* @param data - vector containing all the tasks to be written
	* @return Success in writing file; failure in writing file
	*/
	int save(vector<string>& data); //reads vector, writes to text file
};

#endif

	// End of segment: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\FileProcessing.h





	/**
	 * origin: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\History.cpp
	 */

#include "History.h"


History::History() {
	_undoRecord.clear();
	_redoRecord.clear();
}


int History::undo(HistoryCommand& hist) {
	int currentSize = _undoRecord.size();
	if(currentSize > 0) {
		hist = _undoRecord.back();
		_redoRecord.push_back(_undoRecord.back());
		_undoRecord.pop_back();
		if (currentSize - _undoRecord.size() == CHANGE_IN_HISTORY_SIZE){
			return STATUS_CODE_SET_SUCCESS::SUCCESS_UNDO;
		}
	} else {
		return STATUS_CODE_SET_WARNING::WARNING_UNDO_NO_TASKS;
	}
	return STATUS_CODE_SET_ERROR::ERROR_UNDO;
}


int History::record(HistoryCommand hist) {
	int currentSize = _undoRecord.size();
	_undoRecord.push_back(hist);
	while (_undoRecord.size() > HISTORY_MAX_SIZE) {
		_undoRecord.erase(_undoRecord.begin());
	}
	if (_undoRecord.size() <= HISTORY_MAX_SIZE){
		return STATUS_CODE_SET_SUCCESS::SUCCESS_RECORD;
	}
	return STATUS_CODE_SET_ERROR::ERROR_RECORD;
}

int History::redo(HistoryCommand& hist) {
	int currentSize = _redoRecord.size();
	if(currentSize > 0) {
		hist = _redoRecord.back();
		_undoRecord.push_back(_redoRecord.back());
		_redoRecord.pop_back();
		return STATUS_CODE_SET_SUCCESS::SUCCESS_REDO;
	} else {
		return STATUS_CODE_SET_WARNING::WARNING_REDO_NO_TASKS;
	}
	return STATUS_CODE_SET_ERROR::ERROR_REDO;
}

	// End of segment: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\History.cpp





	/**
	 * origin: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\History.h
	 */


#include "Essential.h"
#include "HistoryCommand.h"


///record past sucessful operations and pop the last one when undo called
class History{
private:
	static const int CHANGE_IN_HISTORY_SIZE = 1;
	static const int HISTORY_MAX_SIZE = 5;
	vector<HistoryCommand> _undoRecord;
	vector<HistoryCommand> _redoRecord;
	
public:
	/**
	* Purpose:
	*Clears the vector containing history actions upon start up
	*/
	History();
	/**
	* Purpose:
	* Retrieves the last action from vector of history records
	* @param hist - last action done will be passed back to calling function via this referenced string
	* @return Success in retrival; Empty records, nothing to be undone; Failure
	*/
	int undo(HistoryCommand& hist);
	/* Purpose:
	* saves the successful action into vectory of history records
	* @param hist - string containing successful user action preformed
	*@return Success in putting the record into history; Failure
	*/
	int record(HistoryCommand hist);
	/**
	* Retrieves the previously undone action
	* @param hist previously undone action will be stored here
	*/
	int redo(HistoryCommand& hist);
	
};

#endif

	// End of segment: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\History.h





	/**
	 * origin: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\UI.cpp
	 */


void UI::UI_interface(){
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	string command;
	bool statusFlag = false;
	displayWelcomeMessage(hConsole);
	while (!statusFlag) {
		displayCommandMessage(command, hConsole);
		displayProcessorMessage(command, hConsole, statusFlag);
	}
}


void UI::displayWelcomeMessage(HANDLE hConsole){
	SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE |FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
	cout << MESSAGE_WELCOME;
	string message;
	vector<string> feedback;
	int output = _processor.UImainProcessor(COMMAND_DISPLAY_TASK_TODAY, message, feedback);
	if (output == STATUS_CODE_SET_OVERALL::OVERALL_SUCCESS) {
		cout << MESSAGE_TASKS_TODAY << endl;
		for (string str:feedback){
			cout << str << endl;
			cout << endl;
		}
	}
	cout << endl;
}


void UI::displayCommandMessage(string& command, HANDLE hConsole){
	SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE |FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
	cout << MESSAGE_COMMAND;
	getline(cin, command);
}


void UI::displayProcessorMessage(string command, HANDLE hConsole, bool& statusFlag){
	string message;
	vector<string> feedback;
	int output = _processor.UImainProcessor(command, message, feedback);
	switch(output){
	case STATUS_CODE_SET_OVERALL::OVERALL_ERROR:
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_INTENSITY);
		break;
	case STATUS_CODE_SET_OVERALL::OVERALL_SUCCESS:
		SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_INTENSITY);
		break;
	case STATUS_CODE_SET_OVERALL::OVERALL_WARNING:
	case STATUS_CODE_SET_OVERALL::OVERALL_PROMPT:
		SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN |FOREGROUND_RED | FOREGROUND_INTENSITY);
		break;
	case STATUS_CODE_SET_OVERALL::OVERALL_EXIT:
		statusFlag = true;
		break;
	}

	assert(!message.empty());
	cout << endl;
	cout << message << endl;

	SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE |FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
	for (string str:feedback){
		cout << str << endl;
		cout << endl;
	}
	cout << endl;


}


	// End of segment: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\UI.cpp





	/**
	 * origin: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\UI.h
	 */


#include <iostream>
#include <Windows.h>
#include <assert.h>
#include "Processor.h"

using namespace std;
using namespace System;

static const string MESSAGE_WELCOME = "Welcome To Tasky! ";
static const string MESSAGE_TASKS_TODAY = "\nThe tasks for today are as follows:\n";
static const string MESSAGE_GOODBYE = "GoodBye!";
static const string MESSAGE_COMMAND = "Command: ";

static const string COMMAND_EXIT = "exit";
static string COMMAND_DISPLAY_TASK_TODAY = "display today";

class UI
{
private:
	Processor _processor;
	/**
	* Purpose:
	* Displays a welcome message to the user
	* Displays the tasks of the day/pending tasks
	*/
	void displayWelcomeMessage(HANDLE hConsole);
	/**
	* Purpose:
	* Takes in user command & put into string command
	* @param command - stores the user input 
	*/
	void displayCommandMessage(string& command, HANDLE hConsole);
	/**
	* Purpose:
	* Send the user's command to the Processor
	*@param command - user input to be passed to Processor
	*/
	void displayProcessorMessage(string command,HANDLE hConsole,bool& statusFlag);
public:
	/**
	* Purpose:
	* Function called when program is started up
	* Takes in user input/commands and passes to Processor
	*Checks if user wishes to exit the program
	*/
	void UI_interface(); //takes in user input
};

#endif

	// End of segment: D:\Mercurial\cs2103-f09-2c\Tasky\Tasky\UI.h





